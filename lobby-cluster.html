<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/bubble_chart.css">
</head>
<body>
<script src="//d3js.org/d3.v5.min.js"></script>
<script src="src/tooltip.js"></script>
<script>
    // tooltip for mouseover functionality
    var tooltip = floatingTooltip('gates_tooltip', 240);
    var data=[];
    var lobby=[];
    var myGroups = new Set();
    var myArrGroups = new Array()

    d3.json("/data/deputates.json").then(function (rawdata) {
        data = rawdata.results.flatMap((d) => {
            groups=d.groups
            return groups.map((b) => {
                myGroups.add(b)
                return {
                    id: d.id,
                    name: d.fullname,
                    group:b
                }
            })
        });
        //data.push({id:0,parent:"",name:"lobby"});//add root node

        var i=0
        myGroups.forEach(function(value) {
            myArrGroups.push({id:i++,val:value});
        });
        getLobby()
        doSomething()
        console.log(data, data.length)
        console.log(myArrGroups,myArrGroups.length)

    });

    function getLobby(){
        d3.json("/data/lobby_group.json").then(function (rawdata) {
            lobby = rawdata.results.map((d) => {
                return {
                    id: d.id,
                    name: d.name,
                }
            })
            console.log("lobby", lobby)
        });

    }




    function doSomething() {


        var width = 1200,
            height = 1000,
            padding = 1, // separation between same-color nodes
            clusterPadding = 10, // separation between different-color nodes
            maxRadius = 4;

        var n = 200, // total number of nodes
            m = 10; // number of distinct clusters

        n = data.length
        m = myArrGroups.length

        var color = d3.scaleSequential(d3.interpolateRainbow)
            .domain(d3.range(m));
        // The largest node for each cluster
        var clusters = new Array(m);

        //var nodes = d3.range(n).map(function () {
        var nodes = data.map(function (d) {
            //var i = Math.floor(Math.random() * m),
            var i = d.group,
                r = Math.sqrt((i + 1) / m * -Math.log(Math.random())) * maxRadius,
                d = {
                    name: d.name,
                    id: d.id,
                    cluster: i,
                    r: r,
                    x: Math.cos(i / m * 2 * Math.PI) * 200 + width / 2 + Math.random(),
                    y: Math.sin(i / m * 2 * Math.PI) * 200 + height / 2 + Math.random()
                };
            if (!clusters[i] || (r > clusters[i].r)) clusters[i] = d;
            //console.log(d)
            return d;
        });
        const margin = {top: 100, right: 100, bottom: 100, left: 100};

        // total number of nodes
        //const n = nodes.length;

        // collect clusters from nodes alternative extended code
        /*const clusters = {};
    nodes.forEach((node) => {
        const radius = node.r;
        const clusterID = node.cluster;
        if (!clusters[clusterID] || (radius > clusters[clusterID].r)) {
            clusters[clusterID] = node;
        }
    });
    console.log('clusters', clusters);*/

        const svg = d3.select('body')
            .append('svg')
            .attr('height', height)
            .attr('width', width)
            .append('g')
        //.attr('transform', `translate(${width / 2},${height / 2})`);

        var force = d3.forceSimulation()
            .nodes(nodes)
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force("gravity", d3.forceManyBody(-1))
            .force("x", d3.forceX().strength(0.1))
            .force("y", d3.forceY().strength(0.1))
            //.force('collide', collide)
            .force('cluster', clustering)
            .force('collide', d3.forceCollide(d => d.r + padding).strength(0.2).iterations(1))
            .on("tick", tick)

        const circles = svg.append('g')
            .datum(nodes)
            .selectAll('.circle')
            .data(d => d)
            .enter().append('circle')
            .attr('r', d => d.r)
            .attr('fill', d => color(d.cluster / 100))
            .attr("cx", d => d.dx)
            .attr("cy", d => d.dy)
            .attr('stroke', 'black')
            .attr('stroke-width', 0.6)
            .on('mouseover', showDetail)
            .on('mouseout', hideDetail)
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        function dragstarted(d) {
            if (!d3.event.active) force.alphaTarget(.03).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }

        function dragended(d) {
            if (!d3.event.active) force.alphaTarget(.03);
            d.fx = null;
            d.fy = null;
        }

        circles.transition()
            .duration(1000)
            .attrTween("r", function (d) {
                var i = d3.interpolate(0, d.r);
                return function (t) {
                    return d.r = i(t);
                };
            });

        function tick() {
            circles
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);
        }

        // Move d to be adjacent to the cluster node.
        function clustering(alpha) {
            nodes.forEach((d) => {
                const cluster = clusters[d.cluster];
                if (cluster === d) return;
                let x = d.x - cluster.x;
                let y = d.y - cluster.y;
                let l = Math.sqrt((x * x) + (y * y));
                const r = d.r + cluster.r;
                if (l !== r) {
                    l = ((l - r) / l) * alpha;
                    d.x -= x *= l;
                    d.y -= y *= l;
                    cluster.x += x;
                    cluster.y += y;
                }
            });
        }

        function collide(alpha) {
            const quadtree = d3.quadtree()
                .x(d => d.x)
                .y(d => d.y)
                .addAll(nodes);

            nodes.forEach((d) => {
                const r = d.r + maxRadius + Math.max(padding, clusterPadding);
                const nx1 = d.x - r;
                const nx2 = d.x + r;
                const ny1 = d.y - r;
                const ny2 = d.y + r;
                quadtree.visit((quad, x1, y1, x2, y2) => {
                    if (quad.data && (quad.data !== d)) {
                        let x = d.x - quad.data.x;
                        let y = d.y - quad.data.y;
                        let l = Math.sqrt((x * x) + (y * y));
                        const r = d.r + quad.data.r + (d.cluster === quad.data.cluster ? padding : clusterPadding);
                        if (l < r) {
                            l = ((l - r) / l) * alpha;
                            d.x -= x *= l;
                            d.y -= y *= l;
                            quad.data.x += x;
                            quad.data.y += y;
                        }
                    }
                    return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
                });
            });
        }


        /*
   * Function called on mouseover to display the
   * details of a bubble in the tooltip.
   */
        function showDetail(d) {
            // change outline to indicate hover state.
            d3.select(this).attr('stroke', 'black');

            var groupname=lobby.find(x => x.id === d.cluster)


            //d3.selectAll("circle").classed("hidden",true)

            var content = '<span class="name">ФИО: </span><span class="value">' +
                d.name +
                '</span><br/>' +
                '<span class="name">Group: </span><span class="value">' +
                d.cluster + ' '+groupname.name+
                '</span><br/>' +
                '<span class="name">ID: </span><span class="value">' +
                d.id +
                '</span>';

            tooltip.showTooltip(content, d3.event);
        }

        /*
     * Hides tooltip
     */
        function hideDetail(d) {
            // reset outline
            d3.select(this)
                .attr('stroke', d3.rgb(color(d.cluster / 10)).darker());

            tooltip.hideTooltip();
        }

        /*
 * Helper function to convert a number into a string
 * and add commas to it to improve presentation.
 */
        function addCommas(nStr) {
            nStr += '';
            var x = nStr.split('.');
            var x1 = x[0];
            var x2 = x.length > 1 ? '.' + x[1] : '';
            var rgx = /(\d+)(\d{3})/;
            while (rgx.test(x1)) {
                x1 = x1.replace(rgx, '$1' + ',' + '$2');
            }

            return x1 + x2;
        }
    }
</script>
</body>
</html>